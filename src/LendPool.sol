// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

interface IUtoken {
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;
}

interface IUnft {
    function mint(address to, uint256 nftTokenId) external;
    function burn(uint256 nftTokenId) external;
}

contract LendPool {
    event Deposited();
    event Withdrawed();
    event Borrowed();
    event Repaid();

    error NullAmount();
    error InvalidAddress();
    error NotEnoughBalance();
    error NotNftOwner();
    error OnlyOneLoan();
    error NftAssetNotAccepted();
    error AssetNotAllowed();
    error BorrowAmountNotAllowed();
    error NotEnoughLiquidity();
    error NoLoan();

    uint256 public totalUnftTokens;

    struct DepositData {
        uint256 balance;
        uint256 lastDeposit;
    }

    struct Loan {
        uint256 amount;
        uint256 nftTokenId;
        bool active;
    }

    address public immutable uToken;
    address public immutable uNFT;

    // AAVE and 1INCH Mainnet addresses
    address aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;
    address oneinch = 0x111111111117dC0aa78b770fA6A738034120C302;

    // Chainlink AAVE/ETH and 1INCH/ETH data feeds
    address aaveEth = 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012;
    address oneinchEth = 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8;

    // NFT collection addresses on Mainnet
    address baycNFT = 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D;
    address azukiNFT = 0xED5AF388653567Af2F388E6224dC7C4b3241C544;
    address beanzNFT = 0x306b1ea3ecdf94aB739F1910bbda052Ed4A9f949;

    // Chainlink aggregators for Ethereum Mainnet
    address baycAgg = 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE;
    address azukiAgg = 0xA8B9A447C73191744D5B79BcE864F343455E1150;
    address beanzAgg = 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90;

    mapping(address => mapping(address => DepositData)) deposits;
    mapping(address => mapping(address => Loan)) loans;

    modifier onlyNftOwner(address nftAddress, uint256 tokenId) {
        if (IERC721(nftAddress).ownerOf(tokenId) != msg.sender) {
            revert NotNftOwner();
        }
        _;
    }

    constructor(address _utoken, address _uNFT) {
        uToken = _utoken;
        uNFT = _uNFT;
    }

    /**
     * @dev Allows users to deposit an 'amount' of tokens to earn an
     *     interest. Users will receive the same amount of ERC20 uTokens 
     *     as the receipt of their deposit.
     * @param asset Address of the asset to be deposited
     * @param amount Amount of tokens to deposit
     * @param onBehalfOf Address who will receive the uTokens
     **/
    function deposit(address asset, uint256 amount, address onBehalfOf) public {
        if (amount == 0) revert NullAmount();
        if (onBehalfOf == address(0)) revert InvalidAddress();

        // Update the user deposit data
        DepositData storage assetDeposit = deposits[onBehalfOf][asset];
        assetDeposit.balance += amount;
        assetDeposit.lastDeposit = block.timestamp;

        // Transfer the asset to Utoken.sol
        IERC20(asset).transferFrom(msg.sender, uToken, amount);

        // Mint uTokens to onBehalfOf address
        IUtoken(uToken).mint(onBehalfOf, amount);

        emit Deposited();
    }

    /**
     * @dev Allows users to withdraw their deposit
     * @param asset Address of the asset to be withdrawed
     * @param amount Amount of tokens to withdraw
     * @param to Address who will receive the amount of tokens and the
     *     interest generated 
     **/
    function withdraw(address asset, uint256 amount, address to) public {
        if (amount == 0) revert NullAmount();
        if (to == address(0)) revert InvalidAddress();

        DepositData storage assetDeposit = deposits[msg.sender][asset];

        if (amount > assetDeposit.balance) revert NotEnoughBalance();

        // Transfer the asset and rewards to "to" address and burn uTokens
        IERC20(asset).transferFrom(uToken, address(this), amount);
        IERC20(asset).transfer(to, amount + calculateRewards(msg.sender, asset, amount));
        IUtoken(uToken).burn(msg.sender, amount);

        // Update the user's deposit data
        assetDeposit.balance -= amount;
        assetDeposit.lastDeposit = block.timestamp;

        emit Withdrawed();
    }

    /**
     * @dev It computes the amount of tokens generated by the deposit interest
     * @param supplier Address of the user who made the deposit
     * @param asset Address of deposited asset
     * @param amount Amount of deposited tokens
     **/
    function calculateRewards(address supplier, address asset, uint256 amount) internal view returns (uint256) {
        // Time in seconds the asset has been deposited
        uint256 time = block.timestamp - deposits[supplier][asset].lastDeposit;
        // Interest (5 % annual)
        uint256 interest = (((time * 5) * 1e18) / 365 days) / 100;

        uint256 rewards = (amount * interest) / 1e18;
        return rewards;
    }

    /**
     * @dev Allows users to borrow an 'amount' of tokens using a NFT
     *     as the loan collateral. Users will receive a uNFT token as
     *     the receipt of their loan.
     * @param asset The address of the asset to borrow
     * @param amount The amount to be borrowed
     * @param nftAsset Address of the NFT collection
     * @param nftTokenId NFT id used as loan collateral
     **/
    function borrow(address asset, uint256 amount, address nftAsset, uint256 nftTokenId)
        public
        onlyNftOwner(nftAsset, nftTokenId)
    {
        Loan storage loan = loans[msg.sender][asset];

        // only 1 loan per user and asset
        if (loan.active) revert OnlyOneLoan();

        // query of NFT price on Chainlink
        address aggregator;

        if (nftAsset == baycNFT) {
            aggregator = baycAgg;
        } else if (nftAsset == azukiNFT) {
            aggregator = azukiAgg;
        } else if (nftAsset == beanzNFT) {
            aggregator = beanzAgg;
        } else {
            revert NftAssetNotAccepted();
        }

        uint256 price = getNftPrice(aggregator);

        // User can borrow maximum 50% of his NFT value
        uint256 maxBorrowAmount = price / 2;

        // Get asset price in Ether
        uint256 assetPrice;

        if (asset == aave) {
            assetPrice = getAssetPrice(aaveEth);
        } else if (asset == oneinch) {
            assetPrice = getAssetPrice(oneinchEth);
        } else {
            revert AssetNotAllowed();
        }

        // asset * (Eth/asset) = Eth (wei units)
        uint256 amountToBorrow = (amount * assetPrice) / 1e18;

        if (amountToBorrow > maxBorrowAmount) revert BorrowAmountNotAllowed();

        // If this contract has not enough money to be borrowed
        if (amount > IERC20(asset).balanceOf(address(this))) revert NotEnoughLiquidity();

        // transfer the NFT to Unft.sol (User must approve this contract
        // to move his NFT)
        IERC721(nftAsset).safeTransferFrom(msg.sender, uNFT, nftTokenId);

        // transfer the tokens to the user
        IERC20(asset).transfer(msg.sender, amount);

        // transfer the uNFT to the user
        IUnft(uNFT).mint(msg.sender, totalUnftTokens + 1);
        totalUnftTokens++;

        // Update loan data
        loan.active = true;
        loan.amount = amount;
        loan.nftTokenId = nftTokenId;

        emit Borrowed();
    }

    /**
     * @dev Allows to get an estimation of the NFT price that is used as loan collateral by the
     *     user.
     * @param nftAddress The Chainlink's aggregator contract address for the NFT collection
     *     whose floor price is returned
     **/
    function getNftPrice(address nftAddress) public view returns (uint256) {
        (, int256 answer,,,) = AggregatorV3Interface(nftAddress).latestRoundData();
        return uint256(answer);
    }

    /**
     * @dev Allows to get an estimation of an asset price in Ether.
     * @param asset Chainlink (asset/Eth) data feed
     **/
    function getAssetPrice(address asset) public view returns (uint256) {
        (, int256 answer,,,) = AggregatorV3Interface(asset).latestRoundData();
        // Reverse the answer to get [Eth/asset] 
        return uint256(1e18 / answer);
    }

    /**
     * @dev Allows to repay a borrowed 'amount'. The 'nftTokenId' is returned
     *     to the user and the uNFT is burned.
     * @param asset Address of the token asset to be repaid
     * @param amount Amount to be repaid (include a small fee of 1%)
     **/
    function repay(address asset, uint256 amount) public {
        Loan storage loan = loans[msg.sender][asset];

        if (!loan.active) revert NoLoan();

        // User must repay the whole loan plus 1% fee
        uint256 fee = loan.amount / 100;
        uint256 amountToRepay = loan.amount + fee;
        if (amount < amountToRepay) revert NotEnoughBalance();

        // Transfer the tokens to LendPool contract. Firstly user must approve
        // this contract to move his funds
        IERC20(asset).transferFrom(msg.sender, address(this), amount);

        // Transfer the NFT from Unft contract to user wallet
        IERC721(uNFT).safeTransferFrom(uNFT, msg.sender, loan.nftTokenId);

        // Burn the user uNFT token
        IUnft(uNFT).burn(loan.nftTokenId);

        // Update loan status
        loan.active = false;

        emit Repaid();
    }
}
